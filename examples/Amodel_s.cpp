/** Code auto-generated by CppODE 0.0.0.9000 **/

#define R_NO_REMAP
#include <R.h>
#include <Rinternals.h>
#include <algorithm>
#include <vector>
#include <cmath>
#include <boost/numeric/odeint.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/matrix.hpp>
#include <cppad/cppad.hpp>

using namespace boost::numeric::odeint;
using boost::numeric::ublas::vector;
using boost::numeric::ublas::matrix;
using AD = CppAD::AD<double>;

// ODE system
struct ode_system {
  vector<AD> params;
  explicit ode_system(const vector<AD>& p_) : params(p_) {}
  void operator()(const vector<AD>& x, vector<AD>& dxdt, const AD& t) {
    dxdt[0] = -CppAD::pow(x[0],2)*params[1]*t;
  }
}; 

// Jacobian for stiff solver
struct jacobian {
  vector<AD> params;
  explicit jacobian(const vector<AD>& p_) : params(p_) {}
  void operator()(const vector<AD>& x, matrix<AD>& J, const AD& t, vector<AD>& dfdt) {
    J(0,0)=-2*x[0]*params[1]*t;
    dfdt[0]=-CppAD::pow(x[0],2)*params[1];
  }
}; 

inline void apply_event(
  vector<AD>& x, int var_index, int method, const AD& value) {
  if (method == 1) {
    x[var_index] = value; // replace
  } else if (method == 2) {
    x[var_index] = x[var_index] + value; // add
  } else if (method == 3) {
    x[var_index] = x[var_index] * value; // multiply
  }
}

struct observer {
  std::vector<AD>& times;
  std::vector<AD>& y;
  const vector<AD>& params;

  explicit observer(std::vector<AD>& t, std::vector<AD>& y_, const vector<AD>& p_)
    : times(t), y(y_), params(p_) {}

  void operator()(vector<AD>& x, const AD& t) {
    if (CppAD::Value(t) == params[2]) apply_event(x, 0, 2, 1);
    if (CppAD::Value(t) == params[3]) apply_event(x, 0, 1, 1);
    times.push_back(t);
    for (size_t i = 0; i < x.size(); ++i) y.push_back(x[i]);
  }
}; 

inline void make_upper_triangle_indices_all(size_t nvars, CppAD::vector<size_t>& row, CppAD::vector<size_t>& col) {
  row.clear(); col.clear();
  for (size_t j = 0; j < nvars; ++j)
    for (size_t k = j; k < nvars; ++k) { row.push_back(j); col.push_back(k); }
}
 
extern "C" SEXP solve_Amodel_s(SEXP timesSEXP, SEXP paramsSEXP, SEXP abstolSEXP, SEXP reltolSEXP) {
  const int x_N = 1;
  const int p_N = 3;
  if (!Rf_isReal(timesSEXP) || Rf_length(timesSEXP) < 2) Rf_error("times must be numeric, length >= 2");
  if (!Rf_isReal(paramsSEXP) || Rf_length(paramsSEXP) != x_N + p_N) Rf_error("params must be numeric length 4");
  if (!Rf_isReal(abstolSEXP) || !Rf_isReal(reltolSEXP)) Rf_error("abstol/reltol must be numeric scalars");

  const int T_N = Rf_length(timesSEXP);
  const double* times  = REAL(timesSEXP);
  const double* params = REAL(paramsSEXP);
  const double abstol  = REAL(abstolSEXP)[0];
  const double reltol  = REAL(reltolSEXP)[0];

  std::vector<AD> indep(x_N + p_N);
  for (int i = 0; i < x_N + p_N; ++i) indep[i] = params[i];
  CppAD::Independent(indep);

  vector<AD> x(x_N);
  for (int i = 0; i < x_N; ++i) x[i] = indep[i];

  vector<AD> full_params(x_N + p_N);
  for (int i = 0; i < x_N + p_N; ++i) full_params[i] = indep[i];

  std::vector<AD> t_ad;
  for (int i = 0; i < T_N; ++i) t_ad.push_back(times[i]);
  t_ad.push_back(full_params[2]);
  t_ad.push_back(full_params[3]);
  std::sort(t_ad.begin(), t_ad.end(), [](const AD& a, const AD& b) { return CppAD::Value(a) < CppAD::Value(b); });

  ode_system sys(full_params);
  jacobian jac(full_params);
  rosenbrock4_controller<rosenbrock4<AD>> stepper(abstol, reltol);
  AD dt = (t_ad.back() - t_ad.front()) / AD(100.0);

  std::vector<AD> result_times;
  std::vector<AD> y;
  observer obs(result_times, y, full_params);
  integrate_times(stepper, std::make_pair(sys, jac), x, t_ad.begin(), t_ad.end(), dt, obs);

  const int n_out = static_cast<int>(result_times.size());
  if (n_out <= 0) Rf_error("Integration produced no output");

  CppAD::ADFun<double> f(indep, y);
  f.optimize();

  CppAD::vector<double> xval(indep.size());
  for (size_t i = 0; i < xval.size(); ++i) xval[i] = CppAD::Value(indep[i]);
  const int nvars = 4;

  const int nrow = n_out, ncol = 16;
  SEXP ans = PROTECT(Rf_allocMatrix(REALSXP, nrow, ncol));
  double* out = REAL(ans);
  auto IDX = [nrow](int r, int c){ return r + c * nrow; };

  for (int i = 0; i < n_out; ++i) {
    out[IDX(i, 0)] = CppAD::Value(result_times[i]);
    for (int s = 0; s < 1; ++s) {
      out[IDX(i, 1 + s)] = CppAD::Value(y[i*1 + s]);
    }
  }

  // First-order sensitivities wrt all independent variables
  const int base_col = 2;
  {
    CppAD::vector<double> J = f.Jacobian(xval);
    for (int i = 0; i < n_out; ++i) {
      for (int s = 0; s < 1; ++s) {
        const int r = i * x_N + s;
        for (int v = 0; v < 4; ++v) {
          const int jcol = v;
          const int Jidx = r * (x_N + p_N) + jcol;
          out[IDX(i, base_col + s * (x_N + p_N) + v)] = J[Jidx];
        }
      }
    }
  }

  // Second-order sensitivities wrt all independent variables (upper triangle)
  const int base2 = 6;
  const int M = 10;
  {
    CppAD::vector<size_t> row, col;
    make_upper_triangle_indices_all(M == 0 ? 0 : (x_N + p_N), row, col);
    CppAD::vector<double> w(f.Range()), h(row.size());
    CppAD::vector<bool> pattern((x_N + p_N) * (x_N + p_N));
    for (size_t iP = 0; iP < pattern.size(); ++iP) pattern[iP] = true;
    CppAD::sparse_hessian_work work;
    for (int i = 0; i < n_out; ++i) {
      for (int s = 0; s < 1; ++s) {
        for (size_t k = 0; k < w.size(); ++k) w[k] = 0.0;
        const int r = i * x_N + s;
        w[r] = 1.0;
        f.SparseHessian(xval, w, pattern, row, col, h, work);
        int idx = 0;
        for (int vj = 0; vj < (x_N + p_N); ++vj) {
          for (int vk = vj; vk < (x_N + p_N); ++vk) {
            out[IDX(i, base2 + s * M + idx)] = h[idx];
            ++idx;
          }
        }
      }
    }
  }

  SEXP coln = PROTECT(Rf_allocVector(STRSXP, 16));
  SET_STRING_ELT(coln, 0, Rf_mkChar("time"));
  SET_STRING_ELT(coln, 1, Rf_mkChar("A"));
  SET_STRING_ELT(coln, 2, Rf_mkChar("A.A"));
  SET_STRING_ELT(coln, 3, Rf_mkChar("A.k1"));
  SET_STRING_ELT(coln, 4, Rf_mkChar("A.t_e"));
  SET_STRING_ELT(coln, 5, Rf_mkChar("A.t_e2"));
  SET_STRING_ELT(coln, 6, Rf_mkChar("A.A.A"));
  SET_STRING_ELT(coln, 7, Rf_mkChar("A.A.k1"));
  SET_STRING_ELT(coln, 8, Rf_mkChar("A.k1.k1"));
  SET_STRING_ELT(coln, 9, Rf_mkChar("A.A.t_e"));
  SET_STRING_ELT(coln, 10, Rf_mkChar("A.k1.t_e"));
  SET_STRING_ELT(coln, 11, Rf_mkChar("A.t_e.t_e"));
  SET_STRING_ELT(coln, 12, Rf_mkChar("A.A.t_e2"));
  SET_STRING_ELT(coln, 13, Rf_mkChar("A.k1.t_e2"));
  SET_STRING_ELT(coln, 14, Rf_mkChar("A.t_e.t_e2"));
  SET_STRING_ELT(coln, 15, Rf_mkChar("A.t_e2.t_e2"));
  SEXP dimn = PROTECT(Rf_allocVector(VECSXP, 2));
  SET_VECTOR_ELT(dimn, 0, R_NilValue);
  SET_VECTOR_ELT(dimn, 1, coln);
  Rf_setAttrib(ans, R_DimNamesSymbol, dimn);

  UNPROTECT(3);
  return ans;
}