/** Code auto-generated by CppODE 0.0.0.9000 **/

#define R_NO_REMAP
#include <R.h>
#include <Rinternals.h>
#include <algorithm>
#include <vector>
#include <cmath>
#include <boost/numeric/odeint.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/matrix.hpp>
#include <StepChecker.hpp>
#include <cppad/cppad.hpp>

using namespace boost::numeric::odeint;
using boost::numeric::ublas::vector;
using boost::numeric::ublas::matrix;
using AD = CppAD::AD<double>;

// ODE system
struct ode_system {
  vector<AD> params;
  explicit ode_system(const vector<AD>& p_) : params(p_) {}
  void operator()(const vector<AD>& x, vector<AD>& dxdt, const AD& t) {
    dxdt[0] = -CppAD::pow(x[0],2)*params[1]*t;
  }
}; 

// Jacobian for stiff solver
struct jacobian {
  vector<AD> params;
  explicit jacobian(const vector<AD>& p_) : params(p_) {}
  void operator()(const vector<AD>& x, matrix<AD>& J, const AD& t, vector<AD>& dfdt) {
    J(0,0)=-2*x[0]*params[1]*t;
    dfdt[0]=-CppAD::pow(x[0],2)*params[1];
  }
}; 

inline void apply_event(
  vector<AD>& x, int var_index, int method, const AD& value) {
  if (method == 1) {
    x[var_index] = value; // replace
  } else if (method == 2) {
    x[var_index] = x[var_index] + value; // add
  } else if (method == 3) {
    x[var_index] = x[var_index] * value; // multiply
  }
}

struct observer {
  std::vector<AD>& times;
  std::vector<AD>& y;
  const vector<AD>& params;

  explicit observer(std::vector<AD>& t, std::vector<AD>& y_, const vector<AD>& p_)
    : times(t), y(y_), params(p_) {}

  void operator()(const vector<AD>& x, const AD& t) {
    vector<AD>& x_nc = const_cast<vector<AD>&>(x);
    if (CppAD::Value(t) == params[2]) apply_event(x_nc, 0, 2, 1);
    times.push_back(t);
    for (size_t i = 0; i < x_nc.size(); ++i) y.push_back(x_nc[i]);
  }
}; 

extern "C" SEXP solve_Amodel_s(SEXP timesSEXP, SEXP paramsSEXP, SEXP abstolSEXP, SEXP reltolSEXP, SEXP maxprogressSEXP, SEXP maxstepsSEXP) {
try {
  const int x_N = 1;
  const int p_N = 2;
  if (!Rf_isReal(timesSEXP) || Rf_length(timesSEXP) < 2) Rf_error("times must be numeric, length >= 2");
  if (!Rf_isReal(paramsSEXP) || Rf_length(paramsSEXP) != x_N + p_N) Rf_error("params must be numeric length 3");
  if (!Rf_isReal(abstolSEXP) || !Rf_isReal(reltolSEXP)) Rf_error("abstol/reltol must be numeric scalars");

  const int T_N = Rf_length(timesSEXP);
  const double* times  = REAL(timesSEXP);
  const double* params = REAL(paramsSEXP);
  const double abstol  = REAL(abstolSEXP)[0];
  const double reltol  = REAL(reltolSEXP)[0];

  if (!Rf_isInteger(maxprogressSEXP) || Rf_length(maxprogressSEXP) != 1) Rf_error("maxprogress must be a single integer");
  if (!Rf_isInteger(maxstepsSEXP) || Rf_length(maxstepsSEXP) != 1) Rf_error("maxsteps must be a single integer");

  int tmp_progress = INTEGER(maxprogressSEXP)[0];
  int tmp_steps    = INTEGER(maxstepsSEXP)[0];
  if (tmp_progress <= 0) Rf_error("maxprogress must be > 0");
  if (tmp_steps    <= 0) Rf_error("maxsteps must be > 0");

  StepChecker checker(tmp_progress, tmp_steps);

  const int sens_xN = 1;
  const int sens_pN = 2;
  const int dom_N = sens_xN + sens_pN;
  const int sens_state_idx[1] = {0};
  const int sens_param_idx[2] = {0,1};
  const int state_sens_pos[1] = {0};
  const int param_sens_pos[2] = {0,1};
  std::vector<AD> indep(dom_N);
// fill sensitive states
  for (int j = 0; j < sens_xN; ++j) indep[j] = params[sens_state_idx[j]];
// fill sensitive params
  for (int j = 0; j < sens_pN; ++j) indep[sens_xN + j] = params[x_N + sens_param_idx[j]];
  CppAD::Independent(indep);

  vector<AD> x(x_N);
// build x from indep or fixed params
  for (int i = 0; i < x_N; ++i) {
    if (state_sens_pos[i] >= 0) x[i] = indep[state_sens_pos[i]];
    else x[i] = params[i];
  }

  vector<AD> full_params(x_N + p_N);
// full_params in original order: [x0..., params...]
  for (int i = 0; i < x_N; ++i) full_params[i] = x[i];
  for (int j = 0; j < p_N; ++j) {
    if (param_sens_pos[j] >= 0) full_params[x_N + j] = indep[sens_xN + param_sens_pos[j]];
    else full_params[x_N + j] = params[x_N + j];
  }

  std::vector<AD> t_ad;
  for (int i = 0; i < T_N; ++i) t_ad.push_back(times[i]);
  t_ad.push_back(full_params[2]);
  std::sort(t_ad.begin(), t_ad.end(), [](const AD& a, const AD& b) { return CppAD::Value(a) < CppAD::Value(b); });

  ode_system sys(full_params);
  jacobian jac(full_params);
  rosenbrock4_controller<rosenbrock4<AD>> stepper(abstol, reltol);
  AD dt = (t_ad.back() - t_ad.front()) / AD(100.0);

  std::vector<AD> result_times;
  std::vector<AD> y;
  observer obs(result_times, y, full_params);
  integrate_times(stepper, std::make_pair(sys, jac), x, t_ad.begin(), t_ad.end(), dt, obs, checker);

  const int n_out = static_cast<int>(result_times.size());
  if (n_out <= 0) Rf_error("Integration produced no output");

  CppAD::ADFun<double> f(indep, y);
  f.optimize();

  CppAD::vector<double> xval(indep.size());
  for (size_t i = 0; i < xval.size(); ++i) xval[i] = CppAD::Value(indep[i]);
  const int nvars = 3;

  const int nrow = n_out, ncol = 5;
  SEXP ans = PROTECT(Rf_allocMatrix(REALSXP, nrow, ncol));
  double* out = REAL(ans);
  auto IDX = [nrow](int r, int c){ return r + c * nrow; };

  for (int i = 0; i < n_out; ++i) {
    out[IDX(i, 0)] = CppAD::Value(result_times[i]);
    for (int s = 0; s < 1; ++s) {
      out[IDX(i, 1 + s)] = CppAD::Value(y[i*1 + s]);
    }
  }

  // First-order sensitivities wrt all independent variables
  const int base_col = 2;
  {
    CppAD::vector<double> J = f.Jacobian(xval);
    for (int i = 0; i < n_out; ++i) {
      for (int s = 0; s < 1; ++s) {
        const int r = i * x_N + s;
        for (int v = 0; v < dom_N; ++v) {
          const int jcol = v;
          const int Jidx = r * dom_N + jcol;
          out[IDX(i, base_col + s * dom_N + v)] = J[Jidx];
        }
      }
    }
  }

  SEXP coln = PROTECT(Rf_allocVector(STRSXP, 5));
  SET_STRING_ELT(coln, 0, Rf_mkChar("time"));
  SET_STRING_ELT(coln, 1, Rf_mkChar("A"));
  SET_STRING_ELT(coln, 2, Rf_mkChar("A.A"));
  SET_STRING_ELT(coln, 3, Rf_mkChar("A.k1"));
  SET_STRING_ELT(coln, 4, Rf_mkChar("A.t_e"));
  SEXP dimn = PROTECT(Rf_allocVector(VECSXP, 2));
  SET_VECTOR_ELT(dimn, 0, R_NilValue);
  SET_VECTOR_ELT(dimn, 1, coln);
  Rf_setAttrib(ans, R_DimNamesSymbol, dimn);

  UNPROTECT(3);
  return ans;
  } catch (const std::exception& e) {
    Rf_error("ODE solver failed: %s", e.what());
  } catch (...) {
    Rf_error("ODE solver failed: unknown C++ exception");
  }
}