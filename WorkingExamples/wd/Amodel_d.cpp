/** Code auto-generated by CppODE 1.0.0 **/

#define R_NO_REMAP
#include <R.h>
#include <Rinternals.h>
#include <algorithm>
#include <vector>
#include <cmath>
#include <cppode/cppode.hpp>

using namespace boost::numeric::odeint;
namespace ublas = boost::numeric::ublas;
using AD = fadbad::F<double>;

namespace {
// ODE system
struct ode_system {
  ublas::vector<AD> params;
  std::vector<const cppode::PchipForcing<AD>*> F;

  ode_system(const ublas::vector<AD>& p_,
             const std::vector<const cppode::PchipForcing<AD>*>& F_)
    : params(p_), F(F_) {}

  void operator()(const ublas::vector<AD>& x,
                  ublas::vector<AD>& dxdt,
                  const AD& t) {
    dxdt[0] = -fadbad::pow(x[0],2.0)*params[3]*t;
    dxdt[1] = fadbad::pow(x[0],2.0)*params[3]*t-x[1]*params[4];
    dxdt[2] = 0.0;
  }
};

// Jacobian for stiff solver
struct jacobian {
  ublas::vector<AD> params;
  std::vector<const cppode::PchipForcing<AD>*> F;

  jacobian(const ublas::vector<AD>& p_,
           const std::vector<const cppode::PchipForcing<AD>*>& F_)
    : params(p_), F(F_) {}

  void operator()(const ublas::vector<AD>& x,
                  ublas::matrix<AD>& J,
                  const AD& t,
                  ublas::vector<AD>& dfdt) {
    J(0,0) = -2.0*x[0]*params[3]*t;
    J(0,1) = 0.0;
    J(0,2) = 0.0;
    J(1,0) = 2.0*x[0]*params[3]*t;
    J(1,1) = -params[4];
    J(1,2) = 0.0;
    J(2,0) = 0.0;
    J(2,1) = 0.0;
    J(2,2) = 0.0;
    dfdt[0] = -fadbad::pow(x[0],2.0)*params[3];
    dfdt[1] = fadbad::pow(x[0],2.0)*params[3];
    dfdt[2] = 0.0;
  }
};

// Observer: stores trajectory values in vectors
struct observer {
  std::vector<AD>& times;
  std::vector<AD>& y;

  explicit observer(std::vector<AD>& t, std::vector<AD>& y_)
    : times(t), y(y_) {}

  void operator()(const ublas::vector<AD>& x, const AD& t) {
    times.push_back(t);
    for (size_t i = 0; i < x.size(); ++i) y.push_back(x[i]);
  }
};

}

extern "C" SEXP solve_Amodel_d(SEXP timesSEXP, SEXP paramsSEXP, SEXP sens1iniSEXP, SEXP sens2iniSEXP, SEXP fixedSEXP, SEXP abstolSEXP, SEXP reltolSEXP, SEXP maxprogressSEXP, SEXP maxstepsSEXP, SEXP hiniSEXP, SEXP root_tolSEXP, SEXP maxrootSEXP, SEXP forcingTimesSEXP, SEXP forcingValuesSEXP) {
try {

  StepChecker checker(INTEGER(maxprogressSEXP)[0], INTEGER(maxstepsSEXP)[0]);

  ublas::vector<AD> x(3);
  ublas::vector<AD> full_params(7);

  // Custom sensitivity initial values
  bool has_sens1ini = !Rf_isNull(sens1iniSEXP);
  double* sens1ini = has_sens1ini ? REAL(sens1iniSEXP) : nullptr;
  if (has_sens1ini) {
    if (Rf_length(sens1iniSEXP) != 3 * 7)
      Rf_error("sens1ini has wrong length");
  }
  if (!Rf_isNull(sens2iniSEXP))
    Rf_error("sens2ini supplied but deriv2 = FALSE");

  const int n_states = 3;
  const int n_sens   = 7;
  auto IDX1 = [n_states](int s, int v) {
    return s + n_states * v;
  };

  // Runtime fixed parameters - O(1) lookup via boolean vector
  std::vector<bool> is_runtime_fixed(n_sens, false);
  if (!Rf_isNull(fixedSEXP)) {
    int* fixed_ptr = INTEGER(fixedSEXP);
    int n_fixed = Rf_length(fixedSEXP);
    for (int i = 0; i < n_fixed; ++i) {
      if (fixed_ptr[i] >= 0 && fixed_ptr[i] < n_sens) {
        is_runtime_fixed[fixed_ptr[i]] = true;
      }
    }
  }
  int n_runtime_fixed = std::count(is_runtime_fixed.begin(), is_runtime_fixed.end(), true);

  // initialize variables
  for (int i = 0; i < 3; ++i) {
    bool is_fixed = false;
    (void)is_fixed;  // suppress unused warning
    x[i] = REAL(paramsSEXP)[i];
    if (!is_fixed && !is_runtime_fixed[i]) {
      if (has_sens1ini) {
        x[i].diff(0, n_sens);  // Allocate
        for (int v = 0; v < n_sens; ++v) {
          x[i].d(v) = sens1ini[IDX1(i, v)];
        }
      } else {
        x[i].diff(i, n_sens);  // Identity: d(i) = 1
      }
    }
    full_params[i] = x[i];
  }

  // initialize parameters
  for (int i = 0; i < 4; ++i) {
    int param_index = 3 + i;
    bool is_fixed = false;
    (void)is_fixed;  // suppress unused warning
    int sens_idx = n_states + i;
    full_params[param_index] = REAL(paramsSEXP)[param_index];
    if (!is_fixed && !is_runtime_fixed[sens_idx]) {
      for (int v = 0; v < n_sens; ++v) {
        // Parameters use identity matrix: dp_i/dp_j = delta_{ij}
        // (sens1ini only provides state sensitivities, not parameter sensitivities)
        double seed = (v == sens_idx ? 1.0 : 0.0);
        if (seed != 0.0) {
          full_params[param_index].diff(v, n_sens);
          full_params[param_index].d(v) *= seed;
        }
      }
    }
  }


  // --- Initialize forcings (PCHIP interpolation) ---
  int n_forcings = Rf_length(forcingTimesSEXP);
  std::vector<cppode::PchipForcing<AD>> forcing_storage(n_forcings);
  std::vector<const cppode::PchipForcing<AD>*> F(n_forcings);

  for (int fi = 0; fi < n_forcings; ++fi) {
    SEXP times_i = VECTOR_ELT(forcingTimesSEXP, fi);
    SEXP values_i = VECTOR_ELT(forcingValuesSEXP, fi);
    int n_points = Rf_length(times_i);

    std::vector<double> ftimes(REAL(times_i), REAL(times_i) + n_points);
    std::vector<double> fvalues(REAL(values_i), REAL(values_i) + n_points);

    forcing_storage[fi].initialize(ftimes, fvalues);
    F[fi] = &forcing_storage[fi];
  }


  // --- Copy integration times ---
  std::vector<double> times_dbl(REAL(timesSEXP), REAL(timesSEXP) + Rf_length(timesSEXP));

  // ensure time zero is included
  if (std::find(times_dbl.begin(), times_dbl.end(), 0.0) == times_dbl.end()) {
    times_dbl.push_back(0.0);
  }

  // sort times ascending and remove duplicates
  std::sort(times_dbl.begin(), times_dbl.end());
  times_dbl.erase(std::unique(times_dbl.begin(), times_dbl.end()), times_dbl.end());

  // convert to AD vector
  std::vector<AD> times;
  times.reserve(times_dbl.size());
  for (double tval : times_dbl) {
    times.emplace_back(tval);
  }

  // storage for results
  std::vector<AD> result_times;
  std::vector<AD> y;

  // --- Event containers ---
  std::vector<FixedEvent<ublas::vector<AD>, AD>> fixed_events;
  std::vector<RootEvent<ublas::vector<AD>, AD>> root_events;
  root_events.push_back(RootEvent<ublas::vector<AD>, AD>{
    [full_params, &F](const ublas::vector<AD>& x, const AD& t){ return x[0]-full_params[6]; },
    0,
    [full_params, &F](const ublas::vector<AD>& x, const AD& t){ return x[1]; },
    EventMethod::Replace});
  fixed_events.emplace_back(FixedEvent<ublas::vector<AD>, AD>{0.0, 0,
    [full_params, &F](const ublas::vector<AD>& x, const AD& t){ return full_params[5]; },
    EventMethod::Add});
  root_events.push_back(RootEvent<ublas::vector<AD>, AD>{
    [full_params, &F](const ublas::vector<AD>& x, const AD& t){ return x[0]-full_params[6]; },
    2,
    [full_params, &F](const ublas::vector<AD>& x, const AD& t){ return x[1]; },
    EventMethod::Replace});

  // --- Solver setup ---
  double abstol = REAL(abstolSEXP)[0];
  double reltol = REAL(reltolSEXP)[0];
  double root_tol = REAL(root_tolSEXP)[0];
  double hini = REAL(hiniSEXP)[0];
  int maxroot = INTEGER(maxrootSEXP)[0];
  ode_system sys(full_params, F);
  jacobian jac(full_params, F);
  observer obs(result_times, y);
  auto controlledStepper = rosenbrock4_controller_pi_ad<rosenbrock4<AD>, true>(abstol, reltol);
  auto denseStepper = rosenbrock4_dense_output_pi_ad<decltype(controlledStepper)>(controlledStepper);

  // --- Determine dt ---
  AD dt;
  if (hini == 0.0) {
    dt = odeint_utils::estimate_initial_dt_local(sys, jac, x, times.front(), abstol, reltol);
  } else {
    dt = hini;
  }

  // --- Integration ---
  integrate_times_dense(denseStepper, std::make_pair(sys, jac), x, times.begin(), times.end(), dt, obs, fixed_events, root_events, checker, root_tol, maxroot);

  const int n_out = static_cast<int>(result_times.size());
  if (n_out <= 0) Rf_error("Integration produced no output");

  // --- Return list(time, variable, sens1) ---
  // Effective sens dimension excludes both compile-time and runtime fixed
  int n_sens_out = n_sens - n_runtime_fixed;

  // Helper to check if index v is fixed (compile-time or runtime)
  auto is_any_fixed = [&is_runtime_fixed](int v) {
    // Compile-time fixed checks
    // No compile-time fixed parameters
    // Runtime fixed check
    return is_runtime_fixed[v];
  };

  SEXP ans = PROTECT(Rf_allocVector(VECSXP, 3));
  SEXP names = PROTECT(Rf_allocVector(STRSXP, 3));
  SET_STRING_ELT(names, 0, Rf_mkChar("time"));
  SET_STRING_ELT(names, 1, Rf_mkChar("variable"));
  SET_STRING_ELT(names, 2, Rf_mkChar("sens1"));
  Rf_setAttrib(ans, R_NamesSymbol, names);

  SEXP time_vec = PROTECT(Rf_allocVector(REALSXP, n_out));
  SEXP variable_mat = PROTECT(Rf_allocMatrix(REALSXP, n_out, 3));
  SEXP sens1_dim = PROTECT(Rf_allocVector(INTSXP, 3));
  INTEGER(sens1_dim)[0] = n_out;
  INTEGER(sens1_dim)[1] = 3;
  INTEGER(sens1_dim)[2] = n_sens_out;
  SEXP sens1_arr = PROTECT(Rf_allocArray(REALSXP, sens1_dim));

  double* time_out = REAL(time_vec);
  double* variable_out = REAL(variable_mat);
  double* sens1_out = REAL(sens1_arr);

  auto IDX_variable = [n_out](int r, int c){ return r + c * n_out; };
  auto IDX_sens1 = [n_out, n_sens_out](int t, int s, int v){ return t + n_out * (s + 3 * v); };

  for (int i = 0; i < n_out; ++i) {
    time_out[i] = result_times[i].x();
    for (int s = 0; s < 3; ++s) {
      AD& xi = y[i * 3 + s];
      variable_out[IDX_variable(i, s)] = xi.x();
      int v_out = 0;
      for (int v = 0; v < 7; ++v) {
        if (!is_any_fixed(v)) {
          sens1_out[IDX_sens1(i, s, v_out)] = xi.d(v);
          v_out++;
        }
      }
    }
  }

  SET_VECTOR_ELT(ans, 0, time_vec);
  SET_VECTOR_ELT(ans, 1, variable_mat);
  SET_VECTOR_ELT(ans, 2, sens1_arr);
  UNPROTECT(6);
  return ans;
  } catch (const std::exception& e) {
    Rf_error("ODE solver failed: %s", e.what());
  } catch (...) {
    Rf_error("ODE solver failed: unknown C++ exception");
  }
}
