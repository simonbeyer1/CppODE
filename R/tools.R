#' Compile generated C++ model code
#'
#' @description
#' Compiles one or more C++ source files generated by \code{CppODE()} or
#' \code{funCpp()} into shared libraries (\code{.so}, \code{.dll}) using
#' \command{R CMD SHLIB}. Source files are located via the \code{"srcfile"}
#' attribute attached to the supplied objects.
#'
#' Compilation is performed in the directory of each source file and does
#' not write to the user's home directory or working directory unless
#' explicitly requested by the user via the \code{outdir} argument when
#' generating the model code.
#'
#' The function automatically applies platform-appropriate compiler flags
#' (e.g. C++20 standard, optimization, position-independent code where
#' required) and includes headers shipped with the package itself as well as
#' Boost headers provided by the \pkg{BH} package.
#'
#' On Windows, compilation is always performed sequentially since
#' fork-based parallelism is unavailable.
#'
#' @param ... One or more objects returned by \code{CppODE()} or
#'   \code{funCpp()} that carry a \code{"srcfile"} attribute pointing to an
#'   existing C or C++ source file.
#' @param output Optional base name for a combined shared library. If
#'   supplied, all provided source files are compiled and linked into a
#'   single shared object.
#' @param args Optional additional compiler or linker arguments passed to
#'   \command{R CMD SHLIB}.
#' @param cores Number of parallel compilation jobs on Unix-like systems.
#'   Ignored on Windows.
#' @param verbose Logical; if \code{TRUE}, show compiler commands and output.
#'
#' @return
#' Invisibly returns \code{TRUE} on successful compilation.
#'
#' @keywords internal
#' @import BH
compile <- function(..., output = NULL, args = NULL, cores = 1, verbose = FALSE) {
  objects <- list(...)

  # --- collect all source files via srcfile attribute ---
  files <- character()
  for (obj in objects) {
    src <- attr(obj, "srcfile")
    if (!is.null(src) && file.exists(src)) {
      files <- union(files, normalizePath(src, winslash = "/", mustWork = FALSE))
    } else if (verbose) {
      message("No valid srcfile attribute found.")
    }
  }

  if (length(files) == 0)
    stop("No valid C/C++ source files found for compilation.")

  # Roots and directories
  roots <- sub("\\.[^.]+$", "", basename(files))
  dirs  <- dirname(files)
  .so   <- .Platform$dynlib.ext

  # --- Clean up old compiled files (same directories as sources) ---
  for (i in seq_along(files)) {
    so_file <- file.path(dirs[i], paste0(roots[i], .so))
    o_file  <- file.path(dirs[i], paste0(roots[i], ".o"))

    # ALWAYS try to unload first (before checking file existence)
    tryCatch(
      dyn.unload(so_file),
      error = function(e) {
        if (verbose) message("Note: Could not unload ", so_file, ": ", e$message)
      }
    )

    # Then delete old files
    if (file.exists(o_file)) {
      unlink(o_file, force = TRUE)
    }
    if (file.exists(so_file)) {
      unlink(so_file, force = TRUE)
      if (file.exists(so_file))
        stop("Could not delete old shared library: ", so_file)
    }
  }

  # --- Compiler flags ---
  if (Sys.info()[["sysname"]] == "Windows") cores <- 1

  include_flags <- paste(
    paste0("-I", system.file("include", package = "CppODE")),
    paste0("-I", system.file("include", package = "BH"))
  )

  sys <- Sys.info()[["sysname"]]
  cxxflags <- if (sys == "Windows") {
    "-std=c++20 -O3 -DNDEBUG -w"
  } else if (sys == "Linux") {
    "-std=c++20 -O3 -DNDEBUG -fPIC -fno-var-tracking-assignments -w"
  } else if (sys == "Darwin") {
    "-std=c++20 -O3 -DNDEBUG -fPIC -w"
  }

  # --- compile one file ---
  compile_one <- function(src, root, dir) {
    old_cppflags <- Sys.getenv("PKG_CPPFLAGS", unset = NA)
    old_cxxflags <- Sys.getenv("PKG_CXXFLAGS", unset = NA)

    Sys.setenv(
      PKG_CPPFLAGS = include_flags,
      PKG_CXXFLAGS = cxxflags
    )

    on.exit({
      if (is.na(old_cppflags)) Sys.unsetenv("PKG_CPPFLAGS")
      else Sys.setenv(PKG_CPPFLAGS = old_cppflags)
      if (is.na(old_cxxflags)) Sys.unsetenv("PKG_CXXFLAGS")
      else Sys.setenv(PKG_CXXFLAGS = old_cxxflags)
    })

    oldwd <- getwd()
    on.exit(setwd(oldwd), add = TRUE)
    setwd(dir)

    cmd <- paste0(
      shQuote(file.path(R.home("bin"), "R")),
      " CMD SHLIB ",
      shQuote(basename(src)),
      if (!is.null(args)) paste(" ", args) else ""
    )

    if (verbose) message(cmd)
    system(cmd, intern = !verbose)

    so_file <- file.path(dir, paste0(root, .so))
    if (!file.exists(so_file))
      stop("Compilation failed for ", src)

    dyn.load(so_file)
    if (verbose) message("\u2713 Loaded ", so_file)
    invisible(root)
  }

  # --- Compilation ---
  if (is.null(output)) {
    if (verbose) message("Compiling ", length(files), " model(s)...")
    parallel::mclapply(
      seq_along(files),
      function(i) compile_one(files[i], roots[i], dirs[i]),
      mc.cores = cores,
      mc.silent = !verbose
    )
  } else {
    # --- Combine all into one shared library ---
    output <- sub("\\.so$", "", output)
    outdir <- dirname(files[1])
    output_so <- file.path(outdir, paste0(output, .so))

    try(dyn.unload(output_so), silent = TRUE)
    if (file.exists(output_so)) unlink(output_so)

    old_cppflags <- Sys.getenv("PKG_CPPFLAGS", unset = NA)
    old_cxxflags <- Sys.getenv("PKG_CXXFLAGS", unset = NA)

    Sys.setenv(
      PKG_CPPFLAGS = include_flags,
      PKG_CXXFLAGS = cxxflags
    )

    on.exit({
      if (is.na(old_cppflags)) Sys.unsetenv("PKG_CPPFLAGS")
      else Sys.setenv(PKG_CPPFLAGS = old_cppflags)
      if (is.na(old_cxxflags)) Sys.unsetenv("PKG_CXXFLAGS")
      else Sys.setenv(PKG_CXXFLAGS = old_cxxflags)
    })

    oldwd <- getwd()
    on.exit(setwd(oldwd), add = TRUE)
    setwd(outdir)

    cmd <- paste0(
      shQuote(file.path(R.home("bin"), "R")),
      " CMD SHLIB ",
      paste(shQuote(basename(files)), collapse = " "),
      " -o ",
      shQuote(basename(output_so)),
      if (!is.null(args)) paste(" ", args) else ""
    )

    if (verbose) message(cmd)
    system(cmd, intern = !verbose)

    if (!file.exists(output_so))
      stop("Compilation failed for combined output")

    dyn.unload(output_so)
    dyn.load(output_so)
    if (verbose) message("\u2713 Loaded ", output_so)
  }

  invisible(TRUE)
}
