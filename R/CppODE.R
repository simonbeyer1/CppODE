#' Generate full C++ code for an ODE model with sensitivities
#'
#' This function orchestrates ODE definition, Jacobian generation,
#' event handling, and sensitivity calculation into a complete C++ file.
#'
#' @param odes Named character vector of ODEs.
#' @param events Optional data.frame of fixed-time events (see GetBoostObserver).
#' @param fixed Not yet implemented.
#' @param compile Logical, compile immediately into shared library?
#' @param modelname Optional string, defaults to random.
#' @param deriv Logical, include first derivatives (Jacobian)?
#' @param secderiv Logical, include second derivatives (Hessian)?
#' @param verbose Logical, print progress?
#'
#' @return Character string of full C++ code.
#' @import reticulate
#' @export
CppFun <- function(odes, events = NULL, fixed = NULL,
                   compile = TRUE, modelname = NULL,
                   deriv = TRUE, secderiv = FALSE, verbose = FALSE) {

  odes <- unclass(odes)
  odes <- gsub("\n", "", odes)
  odes_attr <- attributes(odes)

  # States & params
  states <- names(odes)
  symbols <- getSymbols(c(odes, if (!is.null(events)) c(events$value, events$time)))
  params <- setdiff(symbols, c(states, "time"))

  if (is.null(modelname)) {
    modelname <- paste(c("f", sample(c(letters, 0:9), 8, TRUE)), collapse = "")
  }

  # --- Generate ODE system code ---
  sympy   <- reticulate::import("sympy")
  parser  <- reticulate::import("sympy.parsing.sympy_parser")

  syms_states <- lapply(states, function(s) sympy$Symbol(s, real = TRUE))
  names(syms_states) <- states
  syms_params <- lapply(params, function(p) sympy$Symbol(p, real = TRUE))
  names(syms_params) <- params
  local_dict <- c(syms_states, syms_params)
  local_dict[["time"]] <- sympy$Symbol("time", real = TRUE)

  transformations <- reticulate::tuple(
    c(parser$standard_transformations,
      list(parser$convert_xor, parser$implicit_multiplication_application))
  )

  includings <- c("#define R_NO_REMAP",
                  "#include <R.h>",
                  "#include <Rinternals.h>",
                  "#include <algorithm>",
                  "#include <vector>",
                  "#include <cmath>",
                  "#include <boost/numeric/odeint.hpp>",
                  "#include <boost/numeric/ublas/vector.hpp>",
                  "#include <boost/numeric/ublas/matrix.hpp>",
                  "#include <cppad/cppad.hpp>")

  usings <- c("using namespace boost::numeric::odeint;",
              "using boost::numeric::ublas::vector;",
              "using boost::numeric::ublas::matrix;")

  # USE CppAD:AD if sensitivities are requested
  if(deriv || secderiv) {
    numType = "AD"
    usings <- c(usings, "using AD = CppAD::AD<double>;")
  } else {
    numType = "double"
  }

  ode_lines <- c(
    "// ODE system",
    "struct ode_system {",
    sprintf("  vector<%s> params;", numType),
    sprintf("  void operator()(const vector<%s>& x, vector<%s>& dxdt, const %s& t) {", numType, numType, numType)
  )
  for (i in seq_along(states)) {
    expr <- parser$parse_expr(odes[[i]],
                              local_dict      = local_dict,
                              transformations = transformations,
                              evaluate        = TRUE)
    rhs <- Sympy2CppCode(expr, states, params, length(states), expr_name = states[i])
    rhs <- if (numType == "AD") gsub("std::", "CppAD::", rhs, fixed = TRUE) else rhs
    ode_lines <- c(ode_lines, sprintf("    dxdt[%d] = %s;", i-1, rhs))
  }
  ode_lines <- c(ode_lines, "  }", "};")
  ode_lines <- paste(ode_lines, collapse = "\n")

  # --- Jacobian code ---
  jac <- ComputeJacobianSymb(odes, states = states, params = params, numType = numType)
  jac_lines <- attr(jac, "CppCode")

  # --- Observer code ---
  observer_lines <- GetBoostObserver(states, params, events)

  filename <- paste0(modelname, ".cpp")
  sink(filename)
  cat("/** Code auto-generated by CppODE", as.character(utils::packageVersion("CppODE")), "**/\n\n")
  cat(paste(includings, collapse = "\n"))
  cat("\n\n\n")
  cat(paste(usings, collapse = "\n"))
  cat("\n\n\n")
  cat(ode_lines)
  cat("\n\n\n")
  cat(jac_lines)
  cat("\n\n\n")
  cat(observer_lines)
  cat("\n\n\n")

  sink()

  return(modelname)
}




#' Generate Boost.Odeint observer (fixed-time events with params)
#'
#' This function generates C++ code for a `Boost.Odeint` observer struct
#' that records states at each callback and applies **fixed-time events**
#' exactly when `curr_t == time`.
#'
#' Features:
#' - Events are applied at exact times (no tolerance).
#' - Each event appears at most once (no counters needed).
#' - Allowed methods:
#'   * `1` or `"replace"` → overwrite the state with value
#'   * `2` or `"add"`     → add value to the state
#'   * `3` or `"multiply"`→ multiply the state with value
#' - Event `time` and `value` can be:
#'   * numeric constants
#'   * state names (replaced with `x[index]`)
#'   * parameter names (replaced with `p[index]`, where indices follow after the states)
#'
#' @param states Character vector of state names (order defines `x[i]` indices).
#' @param params Character vector of parameter names (order defines `p[j]` indices,
#'        shifted by `length(states)` in generated code).
#' @param events Optional data frame with columns:
#'   - `var`: state name the event targets
#'   - `time`: numeric constant, state name, or parameter name
#'   - `value`: numeric constant, state name, or parameter name
#'   - `method`: integer (1,2,3) or string ("replace","add","multiply")
#'
#' @return A single character string containing the C++ observer code.
#'
#' @examples
#' states <- c("A","B")
#' params <- c("p1","p2")
#'
#' ev <- data.frame(
#'   var    = c("A","B","A"),
#'   time   = c("p1", "2.0", "5.0"),
#'   value  = c("A", "p2", "3.0"),
#'   method = c("replace", "add", "multiply"),
#'   stringsAsFactors = FALSE
#' )
#'
#' code1 <- GetBoostObserver(states, params, ev)
#' code2 <- GetBoostObserver(states, params)  # no events
#' cat(code1)
#' cat(code2)
#'
#' @export
GetBoostObserver <- function(states, params, events = NULL) {
  stopifnot(is.character(states), length(states) >= 1L)
  stopifnot(is.character(params))

  ev_checks <- ""
  n_ev <- 0L

  if (!is.null(events)) {
    req_cols <- c("var", "time", "value", "method")
    if (!all(req_cols %in% names(events))) {
      stop("`events` must have columns: var, time, value, method")
    }
    if (any(!events$var %in% states)) {
      stop("All events$var must be one of the given `states`.")
    }

    # Map method to integer 1/2/3
    method_map <- c("replace" = 1L, "add" = 2L, "multiply" = 3L)
    events$method <- vapply(events$method, function(m) {
      if (is.numeric(m)) {
        if (!(m %in% 1:3)) stop("Method integers must be 1, 2 or 3.")
        as.integer(m)
      } else if (is.character(m)) {
        ml <- tolower(m)
        if (!ml %in% names(method_map)) stop("Unknown method: ", m)
        method_map[ml]
      } else {
        stop("Invalid method type: must be integer or string.")
      }
    }, integer(1))

    # Map to C++ expression
    cpp_expr <- function(x) {
      num <- suppressWarnings(as.numeric(x))
      if (!is.na(num)) return(sprintf("%.17g", num))
      si <- match(x, states)
      if (!is.na(si)) return(sprintf("x[%d]", si - 1L))
      pi <- match(x, params)
      if (!is.na(pi)) return(sprintf("p[%d]", length(states) + pi - 1L))
      stop("Unknown symbol in event: ", x)
    }

    idx_of <- function(name) match(name, states) - 1L

    checks <- character(nrow(events))
    for (i in seq_len(nrow(events))) {
      vi    <- idx_of(events$var[i])
      texpr <- cpp_expr(events$time[i])
      vexpr <- cpp_expr(events$value[i])
      meth  <- events$method[i]
      checks[i] <- sprintf(
        "    if (CppAD::Value(t) == %s) { apply_event(x, %d, %d, %s); }",
        texpr, vi, meth, vexpr
      )
    }
    ev_checks <- paste(checks, collapse = "\n")
    n_ev <- nrow(events)
  }

  cpp_code <- sprintf('
inline void apply_event(vector<AD>& x, int var_index, int method, const AD& value) {
  if (method == 1) {
    x[var_index] = value;                 // replace
  } else if (method == 2) {
    x[var_index] = x[var_index] + value;  // add
  } else if (method == 3) {
    x[var_index] = x[var_index] * value;  // multiply
  }
}

struct observer {
  std::vector<AD>& times;
  std::vector<AD>& y;
  const vector<AD>& p;

  explicit observer(std::vector<AD>& t, std::vector<AD>& y_, const vector<AD>& p_)
    : times(t), y(y_), p(p_) {}

  void operator()(vector<AD>& x, const AD& t) {
%s
    times.push_back(t);
    for (size_t i = 0; i < x.size(); ++i) y.push_back(x[i]);
  }
};
', if (nzchar(ev_checks)) paste0("\n", ev_checks, "\n") else "")

  attr(cpp_code, "EventNumber") <- n_ev
  return(cpp_code)
}


