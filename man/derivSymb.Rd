% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/symbolics.R
\name{derivSymb}
\alias{derivSymb}
\title{Symbolic Jacobian and Hessian computation using Python's SymPy}
\usage{
derivSymb(f, variables = NULL, deriv2 = FALSE, verbose = FALSE)
}
\arguments{
\item{f}{Named character vector of algebraic expressions. Each name
corresponds to the dependent variable \eqn{f_i}, and the element content
defines the right-hand side expression in terms of other variables.
Both \code{^} and \code{**} are supported for exponentiation.}

\item{variables}{Character vector of variables with respect to which the
derivatives are computed. If \code{NULL} (default), all symbols found
in \code{f} are used as variables.}

\item{deriv2}{Logical; if \code{TRUE}, second derivatives are also
computed and returned as a 3D array (the Hessian tensor). Default is
\code{FALSE}.}

\item{verbose}{Logical; if \code{TRUE}, print diagnostic output during
Python environment setup and SymPy execution. Default is \code{FALSE}.}
}
\value{
If \code{deriv2 = FALSE}, returns a character matrix of first derivatives
(the Jacobian) with dimensions \code{[length(f) × length(variables)]}.
Row names correspond to the names of \code{f}, and column names to
\code{variables}.

If \code{deriv2 = TRUE}, returns a list with two components:
\describe{
\item{jacobian}{Character matrix \code{[n_functions × n_variables]}
    containing \eqn{\partial f_i / \partial v_j}.}
\item{hessian}{Character 3D array \code{[n_functions × n_variables × n_variables]}
    containing \eqn{\partial^2 f_i / (\partial v_j \partial v_k)}.}
}
}
\description{
Computes symbolic first- and second-order derivatives of a system of
algebraic expressions using Python's \strong{SymPy} library via the
\pkg{reticulate} interface. The Jacobian is returned as a matrix and,
optionally, the Hessian as a three-dimensional array.
}
\details{
The function automatically ensures that a Python environment with
\strong{SymPy} is available (via \code{\link{ensurePythonEnv}}). Symbolic
computation is delegated to a Python backend
(\code{inst/python/derivSymb.py}) that implements symbolic differentiation
using SymPy.

Non-analytic expressions such as \code{abs()}, \code{min()}, \code{max()},
and \code{sign()} are supported; their derivatives are expressed using
symbolic constructs such as \code{Heaviside()} or \code{sign()}.

Reserved Python keywords (e.g., \code{if}, \code{for}, \code{lambda}) in
expressions are automatically sanitized by appending an underscore.

If \code{variables} is an empty vector or \code{f} contains no symbols,
an empty matrix or list is returned.
}
\examples{
\dontrun{
# Simple example with named expressions
f <- c(k1 = "exp(K1)", k2 = "exp(K2)")
derivSymb(f)
#>      K1          K2
#> k1 "exp(K1)"   "0"
#> k2 "0"         "exp(K2)"

# Using both ^ and ** for exponentiation
f <- c(y = "a*x^2 + b*x**3")
derivSymb(f, variables = c("x", "a", "b"))
#>   x              a       b
#> y "2*a*x+3*b*x**2" "x**2" "x**3"

# Computing Jacobian and Hessian
result <- derivSymb(f, deriv2 = TRUE)
result$jacobian
result$hessian

# Automatic variable detection
f <- c(z = "alpha + beta*x")
derivSymb(f)  # uses variables = c("alpha", "beta", "x")
}

}
\seealso{
\code{\link{ensurePythonEnv}} for Python environment setup,
\code{\link{getSymbols}} for symbol extraction,
\code{\link{sanitizeExprs}} for expression sanitization.
}
\author{
Simon Beyer, \email{simon.beyer@fdm.uni-freiburg.de}
}
