% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/symbolics.R
\name{derivSymb}
\alias{derivSymb}
\title{Symbolic differentiation (Jacobian and optional Hessian) via SymPy}
\usage{
derivSymb(exprs, real = FALSE, deriv2 = FALSE, fixed = NULL, verbose = FALSE)
}
\arguments{
\item{exprs}{Named character vector of algebraic expressions. Each name
corresponds to a dependent variable \eqn{f_i}, and the element content
defines the right-hand side expression in terms of other variables.
Both \code{^} and \code{**} are supported for exponentiation.}

\item{real}{Logical; if \code{TRUE}, imaginary parts of symbolic expressions
are set to zero post hoc, and real parts are replaced by their argument.
This ensures real-valued simplifications even for non-analytic functions
such as \code{abs()}, \code{max()}, \code{min()}, or \code{sign()}.
Default is \code{FALSE}.}

\item{deriv2}{Logical; if \code{TRUE}, second derivatives (Hessians)
are computed and returned. Default is \code{FALSE}.}

\item{fixed}{Character vector of variable names that should be treated
as \emph{fixed parameters} (no derivatives are computed with respect to them).
Default: \code{NULL}.}

\item{verbose}{Logical; if \code{TRUE}, print diagnostic information
during backend setup and execution. Default is \code{FALSE}.}
}
\value{
A list with components:
\describe{
\item{jacobian}{Character matrix \code{[n_functions × n_variables]}
    containing first derivatives.}
\item{hessian}{List of character arrays \code{[n_variables × n_variables]},
one per function, or \code{NULL} if \code{deriv2 = FALSE}.}
}
}
\description{
Computes symbolic first- and second-order derivatives of a system of
algebraic expressions using Python's \strong{SymPy} library via the
\pkg{reticulate} interface.
}
\details{
The Jacobian (first derivatives) is returned as a character matrix,
and, if requested, the Hessian (second derivatives) as a list of
3D arrays — one per expression.

The Python backend automatically infers all variables occurring in
the expressions using SymPy's internal symbol detection.

This function calls the Python module \code{derivSymb.py} (shipped with the
\pkg{CppODE} package) using \pkg{reticulate}. The Python side performs
symbolic differentiation using SymPy. If \code{variables = NULL},
all free symbols in the expressions are automatically detected.

Setting \code{real = TRUE} simplifies all results under the assumption
that all variables are real, without invoking SymPy's \code{refine()}
(which can cause recursion issues for non-analytic functions).
}
\examples{
\dontrun{
library(CppODE)

eqs <- c(
  f1 = "a*x^2 + b*y^2",
  f2 = "x*y + exp(2*c) + abs(max(x,y))"
)

# Compute Jacobian only
result <- derivSymb(eqs, real = TRUE)
result$jacobian

# Compute Jacobian and Hessian
result2 <- derivSymb(eqs, real = TRUE, deriv2 = TRUE)
result2$hessian[[1]]  # Hessian of f1
}

}
\seealso{
\code{\link[reticulate]{import_from_path}} for Python imports,
and \code{\link{ensurePythonEnv}} for ensuring a Python environment.
}
