% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CppODE.R
\name{CppFun}
\alias{CppFun}
\title{Generate C++ code for ODE models with events and optional sensitivities}
\usage{
CppFun(
  odes,
  events = NULL,
  fixed = NULL,
  includeTimeZero = TRUE,
  compile = TRUE,
  modelname = NULL,
  deriv = TRUE,
  deriv2 = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{odes}{Named character vector of ODE right-hand sides.}

\item{events}{Optional \code{data.frame} describing events. Default: \code{NULL}.}

\item{fixed}{Character vector of fixed states or parameters. Default: \code{NULL}.}

\item{includeTimeZero}{Logical. Include time 0 in integration times. Default: \code{TRUE}.}

\item{compile}{Logical. Compile and load generated C++ code. Default: \code{TRUE}.}

\item{modelname}{Optional base name for C++ file. Default: random identifier.}

\item{deriv}{Logical. Compute first-order sensitivities. Default: \code{TRUE}.}

\item{deriv2}{Logical. Compute second-order sensitivities. Default: \code{FALSE}.}

\item{verbose}{Logical. Print progress messages. Default: \code{FALSE}.}
}
\value{
The model name (character) with attributes: equations, variables, parameters,
events, solver, fixed, jacobian, n_sens.
}
\description{
This function generates and compiles a C++ solver for systems of ODEs using
Boost.Odeint's stiff Rosenbrock 4(3) method with dense output and error control.
The solver can handle fixed-time and root-triggered events, and (optionally)
compute first/second-order sensitivities via forward-mode automatic
differentiation (AD) using FADBAD++.
}
\details{
\subsection{Events}{

Events are specified in a \code{data.frame} with columns:
\describe{
\item{var}{Name of the affected state variable.}
\item{value}{Numeric value to apply at the event.}
\item{method}{How the value is applied: "replace", "add", or "multiply".}
\item{time}{(optional) Time point at which the event occurs.}
\item{root}{(optional) Root expression in terms of states and \code{time}.}
}
Each event must define either \code{time} or \code{root}. Events with roots
are triggered whenever the expression crosses zero.
}

\subsection{Sensitivities}{

The function supports three sensitivity modes:
\describe{
\item{\code{deriv = FALSE, deriv2 = FALSE}}{No sensitivities. Uses plain doubles.
Returns: \code{list(time = numeric[n_out], states = matrix[n_out, n_states])}}
\item{\code{deriv = TRUE, deriv2 = FALSE}}{First-order sensitivities using \code{F<double>}.
Returns: \code{list(time, states, sens1 = array[n_out, n_states, n_sens])}}
\item{\code{deriv = TRUE, deriv2 = TRUE}}{Second-order sensitivities using \code{F<F<double>>}.
Returns: \code{list(time, states, sens1, sens2 = array[n_out, n_states, n_sens, n_sens])}}
}

Fixed states or parameters (specified in \code{fixed}) are excluded from the
sensitivity system. Setting \code{deriv2 = TRUE} requires \code{deriv = TRUE}.
}
}
\examples{
\dontrun{
  # Define ODE system
  eqns <- c(
    A = "-k1 * A^2 * time",
    B = "k1 * A^2 * time - k2 * B"
  )

  # Define an event
  events <- data.frame(
    var    = "A",
    time   = "t_e",
    value  = 1,
    method = "add",
    root   = NA
  )

  # Generate and compile solver (first-order sensitivities)
  f1 <- CppODE::CppFun(
    eqns,
    events = events,
    modelname = "Amodel_s",
    deriv = TRUE,
    deriv2 = FALSE
  )

  # R wrapper for the compiled C++ solver
  solve1 <- function(times, params,
                     abstol = 1e-6, reltol = 1e-6,
                     maxattempts = 5000L, maxsteps = 1e6L,
                     roottol = 1e-8, maxroot = 1L) {

    # Determine parameter order
    paramnames <- c(attr(f1, "variables"), attr(f1, "parameters"))
    missing <- setdiff(paramnames, names(params))
    if (length(missing) > 0)
      stop("Missing parameters: ", paste(missing, collapse = ", "))

    params <- params[paramnames]

    # Call compiled solver
    result <- .Call(
      paste0("solve_", f1),
      as.numeric(times),
      as.numeric(params),
      as.numeric(abstol),
      as.numeric(reltol),
      as.integer(maxattempts),
      as.integer(maxsteps),
      as.numeric(roottol),
      as.integer(maxroot)
    )

    # Extract output components
    states <- attr(f1, "variables")
    sens_vars <- setdiff(c(states, attr(f1, "parameters")), attr(f1, "fixed"))

    # Add dimnames for clarity
    colnames(result$states) <- states
    dimnames(result$sens1) <- list(NULL, states, sens_vars)

    return(result)
  }

  # Define parameters and time grid
  params <- c(A = 1, B = 0, k1 = 0.1, k2 = 0.2, t_e = 3)
  times <- seq(0, 10, length.out = 300)

  # Run solver
  res <- solve1(times, params)

  # Inspect output
  str(res)

}
}
\author{
Simon Beyer, \email{simon.beyer@fdm.uni-freiburg.de}
}
