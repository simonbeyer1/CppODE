% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CppODE.R
\name{CppODE}
\alias{CppODE}
\title{Generate C++ code for ODE models with events and parameter sensitivities}
\usage{
CppODE(
  rhs,
  events = NULL,
  fixed = NULL,
  includeTimeZero = TRUE,
  compile = TRUE,
  modelname = NULL,
  deriv = TRUE,
  deriv2 = FALSE,
  fullErr = TRUE,
  useDenseOutput = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{rhs}{Named character vector of ODE right-hand sides; names must correspond to variables.}

\item{events}{Optional \code{data.frame} describing events (see \strong{Events}). Default: \code{NULL}.}

\item{fixed}{Character vector of fixed initial conditions or parameters (excluded from sensitivities).}

\item{includeTimeZero}{Logical. If \code{TRUE}, ensure that time \code{0} is included among integration times.}

\item{compile}{Logical. If \code{TRUE}, compiles and loads the generated C++ code.}

\item{modelname}{Optional base name for the generated C++ file. If \code{NULL}, a random identifier is used.}

\item{deriv}{Logical. If \code{TRUE}, enable first-order sensitivities via dual numbers.}

\item{deriv2}{Logical. If \code{TRUE}, enable second-order sensitivities via nested dual numbers; requires \code{deriv = TRUE}.}

\item{fullErr}{Logical. If \code{TRUE}, compute error estimates using full state vector including derivatives. If \code{FALSE}, use only the value components for error control.}

\item{useDenseOutput}{Logical. If \code{TRUE}, use dense output (Hermite interpolation).}

\item{verbose}{Logical. If \code{TRUE}, print progress messages.}
}
\value{
The compiled model name (character).
The returned object carries a set of attributes that describe the compiled solver
and its symbolic structure:\tabular{lll}{
   Attribute \tab Type \tab Description \cr
   \code{equations} \tab \code{character} \tab ODE right-hand side definitions \cr
   \code{variables} \tab \code{character} \tab Names of the dynamic state variables \cr
   \code{parameters} \tab \code{character} \tab Names of model parameters \cr
   \code{events} \tab \code{data.frame} \tab Table of event specifications (if any) \cr
   \code{solver} \tab \code{list} \tab Description of the numerical solver configuration \cr
   \code{fixed} \tab \code{character} \tab Names of fixed initial conditions or parameters \cr
   \code{jacobian} \tab \code{eqnvec} \tab Symbolic expressions for the system Jacobian \cr
   \code{deriv} \tab \code{logical} \tab Indicates whether first-order sensitivities (dual numbers) were used \cr
   \code{deriv2} \tab \code{logical} \tab Indicates whether nested dual numbers were used for second-order sensitivities \cr
   \code{dim_names} \tab \code{list} \tab Dimension names for arrays: \code{time}, \code{variable}, and \code{sens} \cr
}
}
\description{
This function generates and compiles a C++ solver for systems of ordinary differential
equations (ODEs) of the form

\deqn{\dot{x}(t) = f\!\big(x(t), p_{\text{dyn}}\big), \quad x(t_0) = p_{\text{init}}}

using \href{https://www.boost.org/doc/libs/1_89_0/libs/numeric/odeint/doc/html/index.html}{\strong{Boost.Odeint's}}
stiff Rosenbrock4 method with dense output and error control (using third order in combination).
The solver supports \strong{time-based} and \strong{root-triggered events} and can, optionally,
compute \strong{first- and second-order sensitivities} by evaluating the \emph{same system} with
\strong{dual number} types provided by
\href{https://uning.dk/fadbad.html}{\strong{FADBAD++}}.
\subsection{Sensitivity Computation}{

If \code{deriv = TRUE}, all state variables and parameters are represented as
\href{https://en.wikipedia.org/wiki/Dual_number}{\strong{dual numbers}} of type \verb{F<double>}.
The ODE right-hand side \eqn{f} is evaluated on these dual numbers; due to the chain rule
encoded in dual number arithmetic, the \strong{derivative components propagate automatically}
through every operation in \eqn{f}. Consequently, the numerical integration solves
\emph{exactly the same} initial value problem, only over the dual number algebra
\eqn{\mathbb{D}}, yielding both the state trajectories and their first derivatives
in a single pass.

If \code{deriv2 = TRUE} (which implies \code{deriv = TRUE}), nested dual numbers
\verb{F<F<double>>} are used. This allows the evaluation of \eqn{f} over the
second-order dual algebra \eqn{\mathbb{D} \otimes \mathbb{D}}, providing \strong{second-order
sensitivities} directly through nested automatic differentiation.

Fixed initial conditions or parameters (listed in \code{fixed}) are created as plain scalars
and therefore do \strong{not} contribute sensitivity components.

If both \code{deriv = FALSE} and \code{deriv2 = FALSE}, plain doubles are used and no sensitivities
are produced.
}

\subsection{Event handling}{

Events are specified in a \code{data.frame} with the following columns:\tabular{ll}{
   Column \tab Description \cr
   \code{var} \tab Name of the affected variable \cr
   \code{value} \tab Numeric value to apply at the event \cr
   \code{method} \tab How the value is applied: \code{"replace"}, \code{"add"}, or \code{"multiply"} \cr
   \code{time} \tab \emph{(optional)} Time point at which the event occurs \cr
   \code{root} \tab \emph{(optional)} Root expression in terms of variables and \code{time} \cr
}


Each event must define either \code{time} or \code{root}.
Root-triggered events fire when the \code{root} expression crosses zero.
}

\subsection{Output}{

The generated solver function (accessible via \code{.Call}) returns a named list:
\itemize{
\item \code{deriv = FALSE}, \code{deriv2 = FALSE}
Returns \code{list(time, variable)}
\itemize{
\item \code{time}: numeric vector of length \eqn{n_t}
\item \code{variable}: numeric matrix \eqn{X_{ij}} of shape \eqn{(n_t,n_x)}, containing \eqn{x_j(t_i)}
}
\item \code{deriv = TRUE}, \code{deriv2 = FALSE}
Returns \code{list(time, variable, sens1)}
\itemize{
\item \code{sens1}: numeric array \eqn{\partial X_{ijk}} of shape \eqn{(n_t,n_x,n_s)}, containing
\eqn{\partial x_j(t_i)/\partial p_k}
}
\item \code{deriv = TRUE}, \code{deriv2 = TRUE}
Returns \code{list(time, variable, sens1, sens2)}
\itemize{
\item \code{sens2}: numeric array \eqn{\partial^2 X_{ijkl}} of shape \eqn{(n_t,n_x,n_s,n_s)},
containing \eqn{\partial^2 x_j(t_i)/\partial p_k\,\partial p_l}
}
}

Here \eqn{n_t} is the number of output time points, \eqn{n_x} the number of state
variables, and \eqn{n_s} the number of sensitivity parameters (non-fixed initials and parameters).
}
}
\examples{
\donttest{
setwd(tempdir())
# Define ODE system
eqns <- c(
  A = "-k1*A^2 * time",
  B = "k1*A^2 * time - k2*B"
)

# Define an event
events <- data.frame(
  var   = "A",
  time  = "t_e",
  value = 1,
  method= "add",
  root  = NA
)

# Generate and compile solver
f <- CppODE(eqns, events = events, modelname = "example", deriv2 = TRUE)

solve <- function(times, params,
                  abstol = 1e-6, reltol = 1e-6,
                  maxattemps = 10L, maxsteps = 7e5L,
                  hini = 0.0, roottol = 1e-10, maxroot = 1L) {

  paramnames <- c(attr(f, "variables"), attr(f, "parameters"))
  missing <- setdiff(paramnames, names(params))
  if (length(missing) > 0) stop("Missing parameters: ", paste(missing, collapse = ", "))
  params <- params[paramnames]
  out <- .Call(paste0("solve_", as.character(f)),
               as.numeric(times),
               as.numeric(params),
               as.numeric(abstol),
               as.numeric(reltol),
               as.integer(maxattemps),
               as.integer(maxsteps),
               as.numeric(hini),
               as.numeric(roottol),
               as.integer(maxroot))

  # Extract dimension names
  dims <- attr(f, "dim_names")

  # Add column names to state matrix
  colnames(out$variable) <- dims$variable

  # Add dimension names to sens1 array if present
  if (!is.null(out$sens1)) {
    dimnames(out$sens1) <- list(NULL, dims$variable, dims$sens)
  }

  if (!is.null(out$sens2)) {
    dimnames(out$sens2) <- list(NULL, dims$variable, dims$sens, dims$sens)
  }

  return(out)
}
# Example run
params <- c(A = 1, B = 0, k1 = 0.1, k2 = 0.2, t_e = 3)
times  <- seq(0, 10, length.out = 300)
res <- solve(times, params)

head(res$time)             # time vector
head(res$variable)         # variables
head(res$sens1[, "B", ])   # Sensitivities of B(t) w.r.t. parameters
res$sens2[10, "A", , ]     # second order sensitivities of A(time[10])
}
}
\author{
Simon Beyer, \href{mailto:simon.beyer@fdm.uni-freiburg.de}{simon.beyer@fdm.uni-freiburg.de}
}
