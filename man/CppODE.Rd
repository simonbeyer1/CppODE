% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CppODE.R
\name{CppODE}
\alias{CppODE}
\title{Generate C++ code for ODE models with events and optional sensitivities}
\usage{
CppODE(
  rhs,
  events = NULL,
  fixed = NULL,
  includeTimeZero = TRUE,
  compile = TRUE,
  modelname = NULL,
  deriv = TRUE,
  deriv2 = FALSE,
  useDenseOutput = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{rhs}{Named character vector of ODE right-hand sides.
Names must correspond to variables.}

\item{events}{Optional \code{data.frame} describing events (see Details).
Default: \code{NULL} (no events).}

\item{fixed}{Character vector of fixed initial conditions or parameters (excluded from
sensitivity system). Only relevant if \code{deriv = TRUE}.}

\item{includeTimeZero}{Logical. If \code{TRUE}, ensure that time \code{0} is
included among integration times. Default: \code{TRUE}.}

\item{compile}{Logical. If \code{TRUE}, compiles and loads the generated C++ code.}

\item{modelname}{Optional base name for the generated C++ file. If \code{NULL},
a random identifier is used.}

\item{deriv}{Logical. If \code{TRUE}, compute first-order sensitivities using AD.
If \code{FALSE}, use plain doubles.}

\item{deriv2}{Logical. If \code{TRUE}, compute second-order sensitivities using
nested AD. Requires \code{deriv = TRUE}. Default: \code{FALSE}.}

\item{useDenseOutput}{Logical. If \code{TRUE}, use dense output for interpolation.}

\item{verbose}{Logical. If \code{TRUE}, print progress messages.}
}
\value{
The model name (character). The object has attributes:
\itemize{
\item \code{equations}: ODE definitions
\item \code{variables}: Variable names
\item \code{parameters}: Parameter names
\item \code{events}: Events \code{data.frame} (if any)
\item \code{solver}: Solver description
\item \code{fixed}: Fixed initial conditions/parameters
\item \code{jacobian}: Symbolic Jacobian expressions
\item \code{deriv}: Logical indicating first-order derivatives
\item \code{deriv2}: Logical indicating second-order derivatives
\item \code{dim_names}: List with dimension names (time, variable, sens)
}
}
\description{
This function generates and compiles a C++ solver for systems of ODEs using
Boost.Odeint's stiff Rosenbrock 4(3) method with dense output and error control.
The solver can handle fixed-time and root-triggered events, and (optionally)
compute parameter sensitivities via forward-mode automatic
differentiation (AD) using FADBAD++.
}
\section{Events}{

Events are specified in a \code{data.frame} with columns:
\describe{
\item{var}{Name of the affected variable.}
\item{value}{Numeric value to apply at the event.}
\item{method}{How the value is applied: "replace", "add", or "multiply".}
\item{time}{(optional) Time point at which the event occurs.}
\item{root}{(optional) Root expression in terms of variables and \code{time}.}
}
Each event must define either \code{time} or \code{root}. Events with roots
are triggered whenever the expression crosses zero.
}

\section{Sensitivities}{

If \code{deriv = TRUE}, the solver augments the system with automatic
differentiation and returns forward sensitivities with respect to initial
conditions and parameters. If \code{deriv2 = TRUE} (requires \code{deriv = TRUE}),
second-order sensitivities are also computed using nested AD types.
Fixed initial conditions or parameters (specified in \code{fixed}) are excluded from
the sensitivity system.

If \code{deriv = FALSE}, the solver uses plain doubles (faster) and does not
compute sensitivities.
}

\section{Output}{

The generated solver function (accessible via \code{.Call}) returns a named list
with the following structure:
\describe{
\item{deriv = FALSE}{
Returns \code{list(time, variable)} where:
\itemize{
\item \code{time}: Numeric vector of length n_out
\item \code{variable}: Numeric matrix with dimensions (n_out, n_variables)
}
}
\item{deriv = TRUE, deriv2 = FALSE}{
Returns \code{list(time, variable, sens1)} where:
\itemize{
\item \code{time}: Numeric vector of length n_out
\item \code{variable}: Numeric matrix with dimensions (n_out, n_variables)
\item \code{sens1}: Numeric array with dimensions (n_out, n_variables, n_sens)
containing first-order sensitivities
}
}
\item{deriv = TRUE, deriv2 = TRUE}{
Returns \code{list(time, variable, sens1, sens2)} where:
\itemize{
\item \code{time}: Numeric vector of length n_out
\item \code{variable}: Numeric matrix with dimensions (n_out, n_variables)
\item \code{sens1}: Numeric array with dimensions (n_out, n_variables, n_sens)
containing first-order sensitivities
\item \code{sens2}: Numeric array with dimensions (n_out, n_variables, n_sens, n_sens)
containing second-order sensitivities (Hessian matrix)
}
}
}
Here \code{n_out} is the number of output time points, \code{n_variables} is the number
of variables, and \code{n_sens} is the number of sensitivity parameters
(non-fixed initial conditions and parameters).
}

\examples{
\dontrun{
  # Define ODE system
  eqns <- c(
    A = "-k1*A^2 * time",
    B = "k1*A^2 * time - k2*B"
  )

  # Define an event
  events <- data.frame(
    var   = "A",
    time  = "t_e",
    value = 1,
    method= "add",
    root  = NA
  )

  # Generate and compile solver
  f <- CppODE(eqns, events = events, modelname = "Amodel_s")

  # Wrap in an R solver function
  solve <- function(times, params,
                    abstol = 1e-8, reltol = 1e-6,
                    maxattemps = 5000, maxsteps = 1e6,
                    roottol = 1e-8, maxroot = 1) {
    paramnames <- c(attr(f, "variables"), attr(f, "parameters"))
    missing <- setdiff(paramnames, names(params))
    if (length(missing) > 0) stop("Missing parameters: ", paste(missing, collapse = ", "))
    params <- params[paramnames]
    out <- .Call(paste0("solve_", as.character(f)),
                 as.numeric(times),
                 as.numeric(params),
                 as.numeric(abstol),
                 as.numeric(reltol),
                 as.integer(maxattemps),
                 as.integer(maxsteps),
                 as.numeric(roottol),
                 as.integer(maxroot))
    colnames(out) <- c("time", attr(f, "variables"), attr(f, "sensvariables"))

    return(out)
  }

  # Example run
  params <- c(A = 1, B = 0, k1 = 0.1, k2 = 0.2, t_e = 3)
  times  <- seq(0, 10, length.out = 300)
  res <- solve(times, params, abstol = 1e-6, reltol = 1e-6)
  head(res)
}
}
\author{
Simon Beyer, \email{simon.beyer@fdm.uni-freiburg.de}
}
