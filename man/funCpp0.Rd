% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CppODE.R
\name{funCpp0}
\alias{funCpp0}
\title{Generate and optionally compile C++ code for algebraic expressions}
\usage{
funCpp0(
  x,
  variables = getSymbols(x, exclude = parameters),
  parameters = NULL,
  compile = FALSE,
  modelname = NULL,
  verbose = FALSE,
  warnings = TRUE,
  deriv = FALSE,
  deriv2 = FALSE
)
}
\arguments{
\item{x}{named character vector of expressions, e.g. \code{c(f1 = "a*x", f2 = "x*y")}}

\item{variables}{character, names of variables (columns of \code{vars})}

\item{parameters}{character, names of parameters (elements of \code{params})}

\item{compile}{logical, if \code{TRUE} write, compile and load the C++ file}

\item{modelname}{character, base name for the generated C++ file}

\item{verbose}{logical, print progress information}

\item{warnings}{logical, warn about missing variables/parameters (filled with 0)}

\item{deriv}{logical, compute symbolic Jacobian (w.r.t. vars + params)}

\item{deriv2}{logical, compute symbolic Hessian (w.r.t. vars + params)}
}
\value{
A function
\preformatted{
  f <- funCpp0(...)
  out <- f(vars, params)
}
where
\itemize{
\item \code{vars} is a \strong{numeric matrix} with columns named by \code{variables}
\item \code{params} is a \strong{named numeric vector} with names \code{parameters}
}

The return value \code{out} is a numeric matrix of size
\verb{[n_obs × n_out]} (observations in rows, expressions in columns).

If \code{deriv = TRUE}, \code{out} has attribute
\preformatted{
  attr(out, "jacobian")  # [n_out × n_sym × n_obs]
}
If \code{deriv2 = TRUE}, \code{out} has attribute
\preformatted{
  attr(out, "hessian")   # [n_out × n_sym × n_sym × n_obs]
}

In addition, the returned \emph{function} carries the symbolic objects:
\preformatted{
  attr(f, "jacobian.symb")  # character matrix  (if deriv = TRUE)
  attr(f, "hessian.symb")   # character array   (if deriv2 = TRUE)
}
}
\description{
\code{funCpp0()} turns a named character vector of algebraic expressions into
(i) a plain R evaluator and (optionally) (ii) a C++ evaluator that can be
compiled and called via \code{.C()}. No Rcpp is used – the generated C++ has a
simple signature
}
\details{
\preformatted{
  void <modelname>_eval(double *x, double *y, double *p,
                        int *n, int *k, int *l)
}

If \code{deriv = TRUE} and/or \code{deriv2 = TRUE}, symbolic first and second
derivatives are obtained from \code{derivSymb()} \strong{with respect to all symbols}
in \code{c(variables, parameters)}. Those symbolic objects are
\itemize{
\item stored on the returned function as attributes
\code{"jacobian.symb"} / \code{"hessian.symb"}, and
\item evaluated on every call and attached to the \strong{result} as numeric
arrays \code{"jacobian"} (3D) and \code{"hessian"} (4D).
}
}
