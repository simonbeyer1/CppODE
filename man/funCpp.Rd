% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CppODE.R
\name{funCpp}
\alias{funCpp}
\title{Generate functions for algebraic models with optional C++ backend and derivatives}
\usage{
funCpp(
  eqns,
  variables = getSymbols(eqns, omit = parameters),
  parameters = NULL,
  fixed = NULL,
  modelname = NULL,
  outdir = tempdir(),
  compile = FALSE,
  verbose = FALSE,
  warnings = TRUE,
  convenient = TRUE,
  deriv = TRUE,
  deriv2 = FALSE
)
}
\arguments{
\item{eqns}{Named character vector or list of algebraic expressions.
Names define the output variables. If unnamed, default names
\code{f1}, \code{f2}, ... are assigned.}

\item{variables}{Character vector of variable names supplied per observation.
If empty or \code{NULL}, the model is treated as purely parametric.}

\item{parameters}{Character vector of parameter names used in the model.}

\item{fixed}{Optional character vector of symbols that are treated as
parameters at evaluation time, even if they appear in \code{variables}.}

\item{modelname}{Optional base name used for generated C++ symbols and files.
If \code{NULL}, a random identifier is generated.}

\item{outdir}{Directory where generated C++ source files are written.}

\item{compile}{Logical; if \code{TRUE}, compile and load the generated C++ code.}

\item{verbose}{Logical; if \code{TRUE}, print progress messages.}

\item{warnings}{Logical; if \code{TRUE}, emit warnings for missing inputs
that are filled with zero.}

\item{convenient}{Logical; if \code{TRUE}, return wrapper functions that
accept named arguments instead of matrices and parameter vectors.}

\item{deriv}{Logical; if \code{TRUE}, enable computation of the Jacobian.}

\item{deriv2}{Logical; if \code{TRUE}, enable computation of the Hessian.}
}
\value{
A list with components:
\describe{
\item{func}{Function evaluating the model output.}
\item{jac}{Function evaluating the Jacobian (if enabled).}
\item{hess}{Function evaluating the Hessian (if enabled).}
}

The returned object carries attributes describing the model, including
the original equations, variables, parameters, and symbolic derivatives
when available.
}
\description{
Generates functions for evaluating a system of algebraic expressions and,
optionally, their Jacobian and Hessian. Model evaluation can be performed
either via generated and compiled C++ code for improved performance or via
a pure R fallback.

The returned object contains callable functions for model evaluation and,
depending on the requested options, for computing first- and second-order
derivatives.
}
\examples{
\dontrun{
# funCpp() makes use of the Python module 'sympy'
eqns <- c(A = "k_p * (k2 + k_d) / (k1*k_d)", B = "k_p/k_d")

f <- funCpp(eqns,
            parameters = c("k_p", "k1", "k2", "k_d"),
            deriv      = TRUE,
            deriv2     = TRUE,
            compile    = TRUE,
            convenient = TRUE)

res <- f(k_p = 0.3, k1 = 0.1, k2 = 0.2, k_d = 0.4, deriv2 = TRUE)

# Output values
res$out

# Jacobian for first (and only) observation
res$jacobian[1, , ]

# Symbolic Jacobian
attributes(f)$jacobian.symb

# Hessian for output "A" at first observation
res$hessian[1, "A", , ]

# Symbolic Hessian
attributes(f)$hessian.symb$A
}


}
