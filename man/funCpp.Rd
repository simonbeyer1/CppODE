% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CppODE.R
\name{funCpp}
\alias{funCpp}
\title{Generate an R/C++ Hybrid Function with Symbolic Derivatives}
\usage{
funCpp(
  x,
  variables = getSymbols(x, exclude = parameters),
  parameters = NULL,
  fixed = NULL,
  compile = FALSE,
  modelname = NULL,
  verbose = FALSE,
  warnings = TRUE,
  convenient = TRUE,
  deriv = TRUE,
  deriv2 = FALSE
)
}
\arguments{
\item{x}{Named character vector of algebraic expressions.
Each name corresponds to an output variable \eqn{f_i}, and each value
defines the expression in terms of the model variables and parameters.}

\item{variables}{Character vector of variable names (independent symbols).
These represent the inputs that vary across observations.}

\item{parameters}{Character vector of parameter names.
Parameters are constant across observations.}

\item{fixed}{Character vector of symbol names that are treated as fixed
constants (excluded from differentiation).}

\item{compile}{Logical; if \code{TRUE}, the generated C++ source code is
compiled immediately and linked via \code{.C()} interface.}

\item{modelname}{Character string; base name for generated C++ functions
and source files. If \code{NULL}, a random name is generated.}

\item{verbose}{Logical; if \code{TRUE}, print diagnostic and progress
information during generation.}

\item{warnings}{Logical; if \code{TRUE}, emit warnings about missing
variables or parameters filled with zero.}

\item{convenient}{Logical; if \code{TRUE}, generate a convenience wrapper
allowing calls of the form \code{f(x = ..., y = ..., a = ..., b = ...)}.}

\item{deriv}{Logical; if \code{TRUE}, compute symbolic first derivatives
(Jacobian).}

\item{deriv2}{Logical; if \code{TRUE}, compute symbolic second derivatives
(Hessian). Requires \code{deriv = TRUE}.}
}
\value{
A function object representing the model.
Attributes include:
\describe{
\item{\code{"equations"}}{Original expressions.}
\item{\code{"variables"}}{Variable symbols.}
\item{\code{"parameters"}}{Parameter symbols.}
\item{\code{"fixed"}}{Fixed symbols excluded from differentiation.}
\item{\code{"jacobian.symb"}}{Character matrix of symbolic Jacobian entries.}
\item{\code{"hessian.symb"}}{List of symbolic Hessian matrices (if requested).}
}
}
\description{
Constructs an algebraic function interface in R, optionally compiled to C++,
including symbolic first- and second-order derivatives.
The symbolic differentiation is performed via Python's \strong{SymPy}
(through \pkg{reticulate}), using the CppODE backend modules
\code{derivSymb.py} and \code{generatefunCppCode.py}.
}
\details{
This function builds a flexible, self-contained model function from
algebraic expressions. The resulting function can evaluate outputs,
Jacobians, and Hessians either:
\itemize{
\item in pure R (interpreted mode), or
\item in compiled C++ form (for high-performance simulation or optimization).
}

Symbolic derivatives are computed automatically using \code{\link{derivSymb}}.
Symbols specified in the \code{fixed} argument are treated as constant
parameters â€” they appear in the generated function environment but are
excluded from symbolic differentiation.
}
\examples{
setwd(tempdir())
eqs <- c(f1 = "a*x^2 + b*y^2",
         f2 = "x*y + exp(2*c)")

derivs <- derivSymb(eqs, deriv2 = T, real = T)
derivs$jacobian
derivs$hessian[["f1"]]
derivs$hessian[["f2"]]


f <- funCpp(eqs,
            variables  = c("x", "y"),
            parameters = c("a", "b", "c"),
            fixed = "c",
            deriv = TRUE,
            deriv2 = TRUE,
            compile = FALSE,
            modelname = "obsfn",
            verbose = TRUE)

res <- f(x = 1:2, y = 1:2, a = 1, b = 2, c = 0)
head(res)

CppODE:::compile(f)
res <- f(x = 1:2, y = 1:2, a = 1, b = 2, c = 0, deriv2 = T)

attr(res,"jacobian")[,,1]
attr(res,"jacobian")[,,2]
attributes(res)$hessian["f2", , , 1]

attr(f,"jacobian.symb")
attr(f,"hessian.symb")$f1
attr(f,"hessian.symb")$f2
}
\seealso{
\code{\link{derivSymb}} for symbolic differentiation backend
}
