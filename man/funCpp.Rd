% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CppODE.R
\name{funCpp}
\alias{funCpp}
\title{Generate a R/C++ evaluator for algebraic models with optional Jacobian/Hessian}
\usage{
funCpp(
  eqns,
  variables = getSymbols(eqns, omit = parameters),
  parameters = NULL,
  fixed = NULL,
  modelname = NULL,
  outdir = tempdir(),
  compile = FALSE,
  verbose = FALSE,
  warnings = TRUE,
  convenient = TRUE,
  deriv = TRUE,
  deriv2 = FALSE
)
}
\arguments{
\item{eqns}{Named character vector or list of expressions (e.g. \code{c(A="k_p*(k2+k_d)/(k1*k_d)", B="k_p/k_d")}).
Names become output column names. If \code{names(eqns)} is \code{NULL}, default names \verb{f1, f2, ...} are used.}

\item{variables}{Character vector of variable names that appear in \code{eqns} and are supplied per observation.
If \code{NULL} or length 0, the model is treated as purely parametric (no per-row variables).}

\item{parameters}{Character vector of parameter names used by the model.}

\item{fixed}{Optional character vector of symbols that should be treated as parameters at evaluation time,
even if they originally appear in \code{variables}. Useful for "fixing" variables temporarily.}

\item{modelname}{Optional base name for the generated C++ source file
\emph{and} for all generated C/C++ symbols (e.g. \code{modelname_eval},
\code{modelname_jacobian}) and the resulting shared library.
If \code{NULL}, a random identifier is used.}

\item{outdir}{Directory where generated C++ source files are written. Defaults to \code{tempdir()}.}

\item{compile}{Logical. If \code{TRUE}, compiles and loads the generated C++ code.}

\item{verbose}{Logical; if \code{TRUE}, prints progress messages.}

\item{warnings}{Logical; if \code{TRUE}, prints soft warnings about missing inputs filled with zeros.}

\item{convenient}{Logical; if \code{TRUE}, returns a wrapper so you can call the function using
\code{f(var1 = ..., var2 = ..., k1 = ..., k2 = ...)} style arguments without
manually assembling matrices/vectors.}

\item{deriv}{Logical; if \code{TRUE}, compute and return the Jacobian. Required if \code{deriv2 = TRUE}.}

\item{deriv2}{Logical; if \code{TRUE}, compute and return the Hessian in addition to the Jacobian.}
}
\value{
A function with signature
\preformatted{
  f(vars, params = numeric(0), attach.input = FALSE, deriv = TRUE, deriv2 = FALSE, verbose = FALSE)
  }
where:
\itemize{
\item \code{vars}: numeric matrix/data frame whose columns match \code{variables} (or \code{NULL} if none).
\item \code{params}: named numeric vector containing all \code{parameters} (missing entries are filled with 0 if allowed).
\item \code{attach.input}: if \code{TRUE}, input variables are prepended to the returned \code{out} matrix.
\item \code{deriv}, \code{deriv2}: request derivatives at call time (must be compatible with how \code{f} was created).
}

The returned list has elements:
\itemize{
\item \code{out}: numeric matrix of outputs with columns named as in \code{eqns}.
\item \code{jacobian}: 3D array \verb{[n_obs, n_out, n_diff_syms]} if \code{deriv=TRUE}.
\item \code{hessian}: 4D array \verb{[n_obs, n_out, n_diff_syms, n_diff_syms]} if \code{deriv2=TRUE}.
}

Attributes on the returned function include:
\itemize{
\item \code{equations}, \code{variables}, \code{parameters}, \code{fixed}, \code{modelname}
\item \code{jacobian.symb} (if \code{deriv=TRUE})
\item \code{hessian.symb}  (if \code{deriv2=TRUE})
}
}
\description{
\code{funCpp()} takes a named vector/list of algebraic expressions and returns an evaluation
function that can compute model outputs and, optionally, symbolic Jacobians and Hessians.
It supports two backends:
\itemize{
\item A compiled C++ backend generated via a small Python helper (recommended for performance).
\item A pure-R fallback that evaluates parsed R expressions.
}

The function automatically:
\itemize{
\item Validates and aligns variable/parameter inputs.
\item Computes symbolic derivatives (via \code{derivSymb()}), if requested.
\item Normalizes derivative arrays so that their row/column orders match the internal
differentiation order used throughout the evaluator.
}
}
\section{Derivative ordering}{

Derivative dimensions always follow \code{diff_syms = c(variables, setdiff(parameters, fixed))}.
Internally, the symbolic Jacobian/Hessian matrices returned by \code{derivSymb()} are reindexed
to this order to ensure compiled and R-fallback paths produce consistent layouts.
}

\section{Array layout}{

Arrays are stored with observations in the first dimension for better memory locality:
\itemize{
\item Jacobian: \verb{[n_obs, n_out, n_diff_syms]}
\item Hessian: \verb{[n_obs, n_out, n_diff_syms, n_diff_syms]}
This allows efficient subsetting like \code{jacobian[1:10, , ]} for the first 10 observations.
}
}

\examples{
\dontrun{
# funCpp() makes use of the Python module 'sympy'
eqns <- c(A = "k_p * (k2 + k_d) / (k1*k_d)", B = "k_p/k_d")

f <- funCpp(eqns,
            parameters = c("k_p", "k1", "k2", "k_d"),
            deriv      = TRUE,
            deriv2     = TRUE,
            compile    = TRUE,
            convenient = TRUE)

res <- f(k_p = 0.3, k1 = 0.1, k2 = 0.2, k_d = 0.4, deriv2 = TRUE)

# Output values
res$out

# Jacobian for first (and only) observation
res$jacobian[1, , ]

# Symbolic Jacobian
attributes(f)$jacobian.symb

# Hessian for output "A" at first observation
res$hessian[1, "A", , ]

# Symbolic Hessian
attributes(f)$hessian.symb$A
}


}
