% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CppODE.R
\name{funCpp}
\alias{funCpp}
\title{Generate and optionally compile C++ code for algebraic expressions}
\usage{
funCpp(
  x,
  variables = getSymbols(x, exclude = parameters),
  parameters = NULL,
  compile = FALSE,
  modelname = NULL,
  verbose = FALSE,
  warnings = TRUE,
  convenient = TRUE,
  deriv = TRUE,
  deriv2 = FALSE
)
}
\arguments{
\item{x}{named character vector of expressions, e.g. \code{c(f1 = "a*x", f2 = "x*y")}}

\item{variables}{character, names of variables (columns of \code{vars})}

\item{parameters}{character, names of parameters (elements of \code{params})}

\item{compile}{logical, if \code{TRUE} write, compile and load the C++ file}

\item{modelname}{character, base name for the generated C++ file}

\item{verbose}{logical, print progress information}

\item{warnings}{logical, warn about missing variables/parameters (filled with 0)}

\item{convenient}{logical, if \code{TRUE} return a function with argument \code{...} to pass
all variables/parameters as named arguments}

\item{deriv}{logical, compute symbolic Jacobian}

\item{deriv2}{logical, compute symbolic Hessian}
}
\value{
If \code{convenient = FALSE}, a function
\preformatted{
  f <- funCpp0(...)
  out <- f(vars, params, attach.input = FALSE)
}
where
\itemize{
\item \code{vars} is a \strong{numeric matrix} with columns named by \code{variables}
\item \code{params} is a \strong{named numeric vector} with names \code{parameters}
}

If \code{convenient = TRUE}, a function
\preformatted{
  f <- funCpp0(...)
  out <- f(..., attach.input = FALSE)
}
where all variables and parameters can be passed as named arguments.

The return value \code{out} is a numeric matrix of size
\verb{[n_obs × n_out]} (observations in rows, expressions in columns).

If \code{deriv = TRUE}, \code{out} has attribute
\preformatted{
  attr(out, "jacobian")  # [n_out × n_sym × n_obs]
}
If \code{deriv2 = TRUE}, \code{out} has attribute
\preformatted{
  attr(out, "hessian")   # [n_out × n_sym × n_sym × n_obs]
}

In addition, the returned \emph{function} carries the symbolic objects:
\preformatted{
  attr(f, "jacobian.symb")  # character matrix  (if deriv = TRUE)
  attr(f, "hessian.symb")   # character array   (if deriv2 = TRUE)
}
}
\description{
\code{funCpp()} turns a named character vector of algebraic expressions into
(i) a plain R evaluator and (optionally) (ii) a C++ evaluator that can be
compiled and and will then internally be called via \code{.C()}.
}
\details{
If \code{deriv = TRUE} and/or \code{deriv2 = TRUE}, symbolic first and second
derivatives are obtained from \code{derivSymb()} \strong{with respect to all symbols}
found within the expressions \code{x}. Those symbolic objects are evaluated on every call and attached to the \strong{result} as numeric
arrays \code{"jacobian"} (3D) and \code{"hessian"} (4D).
}
\examples{
\dontrun{
# Without convenient mode
f <- funCpp0(c(y = "a*x^2 + b"), convenient = FALSE)
M <- matrix(1:10, ncol = 1, dimnames = list(NULL, "x"))
p <- c(a = 2, b = 3)
f(M, p)

# With convenient mode (default)
f <- funCpp0(c(y = "a*x^2 + b"), convenient = TRUE)
f(x = 1:10, a = 2, b = 3, attach.input = TRUE)
}

}
