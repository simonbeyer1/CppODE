% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CppODE.R
\name{funCpp}
\alias{funCpp}
\title{Create and (optionally) compile C++ code for algebraic expressions}
\usage{
funCpp(
  x,
  variables = getSymbols(x, exclude = parameters),
  parameters = NULL,
  compile = FALSE,
  modelname = NULL,
  verbose = FALSE,
  warnings = TRUE,
  convenient = TRUE,
  deriv = TRUE,
  deriv2 = FALSE
)
}
\arguments{
\item{x}{Named character vector of algebraic expressions.}

\item{variables}{Character vector of variable names.}

\item{parameters}{Character vector of parameter names.}

\item{compile}{Logical; if \code{TRUE}, generate, compile, and load the C++ code.}

\item{modelname}{Optional base name for generated files.}

\item{verbose}{Logical; print diagnostic output.}

\item{warnings}{Logical; warn about missing variables or parameters
(filled with zeros).}

\item{convenient}{Logical; if \code{TRUE} (default), return a wrapper function
that accepts variables and parameters as \code{...}.}

\item{deriv}{Logical; if \code{TRUE}, compute the symbolic Jacobian.}

\item{deriv2}{Logical; if \code{TRUE}, compute the symbolic Hessian
(implies \code{deriv = TRUE}).}
}
\value{
A callable function that evaluates the system of equations.

The output of the function call is a numeric matrix
\verb{[n_obs × n_outputs]}.  If derivatives are available,
attributes \code{"jacobian"} (\verb{[n_out × n_sym × n_obs]}) and
\code{"hessian"} (\verb{[n_out × n_sym × n_sym × n_obs]}) are attached.

The returned function itself also carries the symbolic representations:
\itemize{
\item \code{attr(f, "jacobian.symb")} – character matrix of analytic first derivatives
\item \code{attr(f, "hessian.symb")} – character 3D array of analytic second derivatives
}

If symbolic parsing fails for R fallback (e.g. due to \code{Piecewise} or
\code{DiracDelta}), a warning is issued at creation time and only compiled
evaluation will be available.
}
\description{
\code{funCpp()} transforms a named character vector of algebraic expressions
into an R callable function that evaluates them either in pure R or through
an automatically generated and compiled C++ backend.
}
\details{
If symbolic derivatives are requested (\code{deriv = TRUE} or \code{deriv2 = TRUE}),
the function uses \code{\link[=derivSymb]{derivSymb()}} to compute analytic Jacobians and
Hessians via \strong{SymPy} (Python).  The symbolic results are attached both to
the returned function and, when evaluated, as numeric derivative arrays.

Complex symbolic forms that cannot be parsed by R (for example,
\code{Piecewise()} or \code{DiracDelta()}) are detected automatically.  In such
cases, the pure-R fallback is disabled and a clear warning is issued,
advising the user to use \code{compile = TRUE} for C++ evaluation.
}
\examples{
\dontrun{
f <- funCpp(c(y = "a*x^2 + b*y^2"), deriv2 = TRUE)
f(x = 1:3, y = 2, a = 0.5, b = 1)
attr(f, "jacobian.symb")
attr(f, "hessian.symb")
}

}
\seealso{
\code{\link[=derivSymb]{derivSymb()}} for symbolic differentiation,
\code{\link[=ensurePythonEnv]{ensurePythonEnv()}} for Python setup.
}
