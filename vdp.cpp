/** Code auto-generated by CppODE 0.0.0.9000 **/

#define R_NO_REMAP
#include <R.h>
#include <Rinternals.h>
#include <algorithm>
#include <vector>
#include <cmath>
#include <boost/numeric/odeint.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/matrix.hpp>
#include <cppad/cppad.hpp>


using namespace boost::numeric::odeint;
using boost::numeric::ublas::vector;
using boost::numeric::ublas::matrix;
using AD = CppAD::AD<double>;


// ODE system
struct ode_system {
  vector<AD> params;
  void operator()(const vector<AD>& x, vector<AD>& dxdt, const AD& t) {
    dxdt[0] = x[1];
    dxdt[1] = params[4]*x[1]*(1-std::pow(x[0],2))-x[0];
    dxdt[2] = x[3]*std::max(x[1],x[0]);
    dxdt[3] = -x[3]*params[5]*x[1]*x[0];
  }
};


// Jacobian for stiff solver
struct jacobian {
  vector<AD> params;
  void operator()(const vector<AD>& x, matrix<AD>& J, const AD& t, vector<AD>& dfdt) {
    J(0,0)=0;
    J(0,1)=1;
    J(0,2)=0;
    J(0,3)=0;
    J(1,0)=-2*params[4]*x[1]*x[0]-1;
    J(1,1)=params[4]*(1-std::pow(x[0],2));
    J(1,2)=0;
    J(1,3)=0;
    J(2,0)=x[3]*(((x[1]-x[0]>0)?(0):((x[1]-x[0]==0)?(1.0/2.0):(1))));
    J(2,1)=x[3]*(((x[1]-x[0]<0)?(0):((x[1]-x[0]==0)?(1.0/2.0):(1))));
    J(2,2)=0;
    J(2,3)=std::max(x[1],x[0]);
    J(3,0)=-x[3]*params[5]*x[1];
    J(3,1)=-x[3]*params[5]*x[0];
    J(3,2)=0;
    J(3,3)=-params[5]*x[1]*x[0];
    dfdt[0]=0;
    dfdt[1]=0;
    dfdt[2]=0;
    dfdt[3]=0;
  }
};



inline void apply_event(vector<AD>& x, int var_index, int method, const AD& value) {
  if (method == 1) {
    x[var_index] = value;                 // replace
  } else if (method == 2) {
    x[var_index] = x[var_index] + value;  // add
  } else if (method == 3) {
    x[var_index] = x[var_index] * value;  // multiply
  }
}

struct observer {
  std::vector<AD>& times;
  std::vector<AD>& y;
  const vector<AD>& p;

  explicit observer(std::vector<AD>& t, std::vector<AD>& y_, const vector<AD>& p_)
    : times(t), y(y_), p(p_) {}

  void operator()(vector<AD>& x, const AD& t) {

    times.push_back(t);
    for (size_t i = 0; i < x.size(); ++i) y.push_back(x[i]);
  }
};



